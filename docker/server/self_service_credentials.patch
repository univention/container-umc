The self-service uses a hardcoded database host and credentials,
and a hardcoded memcached socket.

This makes the Postgres and Memcached connection settings configurable.

diff --git /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/__init__.py /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/__init__.py
index f7ce009d2c..d50f4b8f3b 100644
--- /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/__init__.py
+++ /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/__init__.py
@@ -36,6 +36,7 @@

 import datetime
 import email.charset
+import os
 import os.path
 import random
 import smtplib
@@ -72,7 +73,9 @@ from .tokendb import MultipleTokensInDB, TokenDB

 _ = Translation('univention-self-service-passwordreset-umc').translate

-MEMCACHED_SOCKET = "/var/lib/univention-self-service-passwordreset-umc/memcached.socket"
+MEMCACHED_SOCKET = os.getenv("SELF_SERVICE_MEMCACHED_SERVER", "/var/lib/univention-self-service-passwordreset-umc/memcached.socket")
+MEMCACHED_USERNAME = os.getenv("SELF_SERVICE_MEMCACHED_USER")
+MEMCACHED_SECRET_FILE = os.getenv("SELF_SERVICE_MEMCACHED_SECRET_FILE")
 MEMCACHED_MAX_KEY = 250

 SELFSERVICE_MASTER = ucr.get("self-service/backend-server", ucr.get("ldap/master"))
@@ -258,7 +261,16 @@ class Instance(Base):
             atexit.register(self.db.close_db)
             if not self.db.table_exists():
                 self.db.create_table()
-            self.memcache = pylibmc.Client([MEMCACHED_SOCKET], binary=True)
+            if MEMCACHED_SECRET_FILE:
+                try:
+                    with open(MEMCACHED_SECRET_FILE) as pw_file:
+                        password = pw_file.readline().strip()
+                except (OSError, IOError) as e:
+                    self.logger.error(f"Instance.init(): Could not read {MEMCACHED_SECRET_FILE}: {e}")
+                    raise
+            else:
+                password = None
+            self.memcache = pylibmc.Client([MEMCACHED_SOCKET], binary=True, username=MEMCACHED_USERNAME, password=password)

         self.send_plugins = get_sending_plugins(MODULE.process)
         self.password_reset_plugins = {k: v for k, v in self.send_plugins.items() if v.message_application() == 'password_reset'}
diff --git /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/tokendb.py /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/tokendb.py
index e4266b4ae8..842457fd8e 100644
--- /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/tokendb.py
+++ /usr/lib/python3/dist-packages/univention/management/console/modules/passwordreset/tokendb.py
@@ -35,15 +35,18 @@
 # <https://www.gnu.org/licenses/>.

 import datetime
+import os
 import traceback

 import psycopg2
 import psycopg2.extras


-DB_USER = "selfservice"
-DB_NAME = "selfservice"
-DB_SECRETS_FILE = "/etc/self-service-db.secret"
+DB_HOST = os.getenv("SELF_SERVICE_DB_HOST", "localhost")
+DB_PORT = os.getenv("SELF_SERVICE_DB_PORT", "5432")
+DB_USER = os.getenv("SELF_SERVICE_DB_USER", "selfservice")
+DB_NAME = os.getenv("SELF_SERVICE_DB_NAME", "selfservice")
+DB_SECRETS_FILE = os.getenv("SELF_SERVICE_DB_SECRET_FILE", "/etc/self-service-db.secret")


 class MultipleTokensInDB(Exception):
@@ -120,8 +123,8 @@ token VARCHAR(255) NOT NULL);""")
             self.logger.error(f"db_open(): Could not read {DB_SECRETS_FILE}: {e}")
             raise
         try:
-            conn = psycopg2.connect("dbname={db_name} user={db_user} host='localhost' password='{db_pw}'".format(
-                db_name=DB_NAME, db_user=DB_USER, db_pw=password))
+            conn = psycopg2.connect("dbname={db_name} user={db_user} host='{db_host}' port={db_port} password='{db_pw}'".format(
+                db_name=DB_NAME, db_user=DB_USER, db_pw=password, db_host=DB_HOST, db_port=DB_PORT))
             self.logger.info("db_open(): Connected to database '{}' on server with version {} using protocol version {}.".format(
                 DB_NAME, conn.server_version, conn.protocol_version))
             return conn
